var gl = require('./build/default/node-webgl.node');

var GLenum = "number";
var GLint = "number";
var GLuint = "number";
var GLfloat = "number";
var GLclampf = "number";
var GLsizeiptr = "number";
var GLintptr = "number";
var GLbitfield = "number";
var GLboolean = "boolean";
var GLsizei = "number";
var DOMString = "string";
var any = "string";
function WebGLUniformLocation(_) { this._ = _; }
function WebGLBuffer(_) { this._ = _; }
function WebGLProgram(_) { this._ = _; }
function WebGLShader(_) { this._ = _; }
function WebGLFramebuffer(_) { this._ = _; }
function WebGLRenderbuffer(_) { this._ = _; }
function WebGLTexture(_) { this._ = _; }
function WebGLActiveInfo(_) { this._ = _; }


// These needs to be implemented
function ArrayBufferView() {}
function FloatArray() {}
function ImageData() {}
function Int32Array() {}

console.log("// Generated by " + __filename + "\n");
process.stdout.write("var gl = module.exports = require('./build/default/node-webgl.node');\n\n");


var funcs = [];
// Wrap raw C++ functions in nice JavaScript type checking and arguments
// Also wrap raw integer's in proper webgl objects

forEach({
  activeTexture: { args: { texture: GLenum }},
  attachShader: { args: { program: WebGLProgram, shader: WebGLShader }},
  bindAttribLocation: { args: { program: WebGLProgram, index: GLuint, name: DOMString }},
  bindBuffer: { args: { target: GLenum, buffer: WebGLBuffer }},
  bindFramebuffer: { args: { target: GLenum, framebuffer: WebGLFramebuffer }},
  bindRenderbuffer: { args: { target: GLenum, renderbuffer: WebGLRenderbuffer }},
  bindTexture: { args: { target: GLenum, texture: WebGLTexture }},
  blendColor: { args: { red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf }},
  blendEquation: { args: { mode: GLenum }},
  blendEquationSeparate: { args: { modeRGB: GLenum, modeAlpha: GLenum }},
  blendFunc: { args: { sfactor: GLenum, dfactor: GLenum }},
  blendFuncSeparate: { args: { srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum }}, 

//  bufferData: { args: { target: GLenum, size: GLsizeiptr, usage: GLenum }},
//  bufferData: { args: { target: GLenum, data: ArrayBufferView, usage: GLenum }},
  bufferData: { args: { target: GLenum, data: ArrayBuffer, usage: GLenum }},
//  bufferSubData: { args: { target: GLenum, offset: GLintptr, data: ArrayBufferView }},
  bufferSubData: { args: { target: GLenum, offset: GLintptr, data: ArrayBuffer }},
  
  checkFramebufferStatus: { result: GLenum, args: { target: GLenum }},
  clear: { args: { mask: GLbitfield }},
  clearColor: { args: { red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf }},
  clearDepth: { args: { depth: GLclampf }},
  clearStencil: { args: { s : GLint }},
  colorMask: { args: { red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean }},
  compileShader: { args: { shader: WebGLShader }},


  copyTexImage2D: { args: { target: GLenum, level: GLint, internalformat: GLenum, 
                    x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint }},
  copyTexSubImage2D: { args: { target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, 
                       x: GLint, y: GLint, width: GLsizei, height: GLsizei }},

  createBuffer: { result: WebGLBuffer, args: {} },
  createFramebuffer: { result: WebGLFramebuffer, args: {} },
  createProgram: { result: WebGLProgram, args: {} },
  createRenderbuffer: { result: WebGLRenderbuffer, args: {} },
  createShader: { result: WebGLShader, args: { type: GLenum }},
  createTexture: { result: WebGLTexture, args: {} },

  cullFace: { args: { mode: GLenum }},

  deleteBuffer: { args: { buffer: WebGLBuffer }},
  deleteFramebuffer: { args: { framebuffer: WebGLFramebuffer }},
  deleteProgram: { args: { program: WebGLProgram }},
  deleteRenderbuffer: { args: { renderbuffer: WebGLRenderbuffer }},
  deleteShader: { args: { shader: WebGLShader }},
  deleteTexture: { args: { texture: WebGLTexture }},

  depthFunc: { args: { func: GLenum }},
  depthMask: { args: { flag: GLboolean }},
  depthRange: { args: { zNear: GLclampf, zFar: GLclampf }},
  detachShader: { args: { program: WebGLProgram, shader: WebGLShader }},
  disable: { args: { cap: GLenum }},
  disableVertexAttribArray: { args: { index: GLuint }},
  drawArrays: { args: { mode: GLenum, first: GLint, count: GLsizei }},
  drawElements: { args: { mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr }},

  enable: { args: { cap: GLenum }},
  enableVertexAttribArray: { args: { index: GLuint }},
  finish: { args: {}},
  flush: { args: {}},
  framebufferRenderbuffer: { args: { target: GLenum, attachment: GLenum, 
                             renderbuffertarget: GLenum, renderbuffer: WebGLRenderbuffer }},
  framebufferTexture2D: { args: { target: GLenum, attachment: GLenum, textarget: GLenum,
                              texture: WebGLTexture, level: GLint }},
  frontFace: { args: { mode: GLenum }},

  generateMipmap: { args: { target: GLenum }},
    
  getActiveAttrib: { result: WebGLActiveInfo, args: { program: WebGLProgram, index: GLuint }},
  getActiveUniform: { result: WebGLActiveInfo, args: { program: WebGLProgram, index: GLuint }},
  getAttachedShaders: { result: [WebGLShader], args: { program: WebGLProgram }},

  getAttribLocation: { result: GLint, args: { program: WebGLProgram, name: DOMString }},

  getParameter: { result: any, args: { pname: GLenum }},
  getBufferParameter: { result: any, args: { target: GLenum, pname: GLenum }},

  getError: { result: GLenum, args: {}},

  getFramebufferAttachmentParameter: { result: any, args: { target: GLenum, attachment: GLenum, pname: GLenum }},
  getProgramParameter: { result: any, args: { program: WebGLProgram, pname: GLenum }},
  getProgramInfoLog: { result: DOMString, args: { program: WebGLProgram }},
  getRenderbufferParameter: { result: any, args: { target: GLenum, pname: GLenum }},
  getShaderParameter: { result: any, args: { shader: WebGLShader, pname: GLenum }},
  getShaderInfoLog: { result: DOMString, args: { shader: WebGLShader }},

  getShaderSource: { result: DOMString, args: { shader: WebGLShader }},

  getTexParameter: { result: any, args: { target: GLenum, pname: GLenum }},

  getUniform: { result: any, args: { program: WebGLProgram, location: WebGLUniformLocation }},
  
  getUniformLocation: { result: WebGLUniformLocation, args: { program: WebGLProgram, name: DOMString }},

  getVertexAttrib: { result: any, args: { index: GLuint, pname: GLenum }},

  getVertexAttribOffset: { result: GLsizeiptr, args: { index: GLuint, pname: GLenum }},

  hint: { args: { target: GLenum, mode: GLenum }},
  isBuffer: { result: GLboolean, args: { buffer: WebGLBuffer }},
  isEnabled: { result: GLboolean, args: { cap: GLenum }},
  isFramebuffer: { result: GLboolean, args: { framebuffer: WebGLFramebuffer }},
  isProgram: { result: GLboolean, args: { program: WebGLProgram }},
  isRenderbuffer: { result: GLboolean, args: { renderbuffer: WebGLRenderbuffer }},
  isShader: { result: GLboolean, args: { shader: WebGLShader }},
  isTexture: { result: GLboolean, args: { texture: WebGLTexture }},
  lineWidth: { args: { width: GLfloat }},
  linkProgram: { args: { program: WebGLProgram }},
  pixelStorei: { args: { pname: GLenum, param: GLint }},
  polygonOffset: { args: { factor: GLfloat, units: GLfloat }},

  readPixels: { args: { x: GLint, y: GLint, width: GLsizei, height: GLsizei, 
                    format: GLenum, type: GLenum, pixels: ArrayBufferView }},

  renderbufferStorage: { args: { target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei }},
  sampleCoverage: { args: { value: GLclampf, invert: GLboolean }},
  scissor: { args: { x: GLint, y: GLint, width: GLsizei, height: GLsizei }},

  shaderSource: { args: { shader: WebGLShader, source: DOMString }},

  stencilFunc: { args: { func: GLenum, ref: GLint, mask: GLuint }},
  stencilFuncSeparate: { args: { face: GLenum, func: GLenum, ref: GLint, mask: GLuint }},
  stencilMask: { args: { mask: GLuint }},
  stencilMaskSeparate: { args: { face: GLenum, mask: GLuint }},
  stencilOp: { args: { fail: GLenum, zfail: GLenum, zpass: GLenum }},
  stencilOpSeparate: { args: { face: GLenum, fail: GLenum, zfail: GLenum, zpass: GLenum }},


  texImage2D: { args: { target: GLenum, level: GLint, internalformat: GLenum, 
                        width: GLsizei, height: GLsizei, border: GLint, format: GLenum, 
                        type: GLenum, pixels: ArrayBufferView }},
//  texImage2D: { args: { target: GLenum, level: GLint, internalformat: GLenum,
//                        format: GLenum, type: GLenum, pixels: ImageData }}, 


  texParameterf: { args: { target: GLenum, pname: GLenum, param: GLfloat }},
  texParameteri: { args: { target: GLenum, pname: GLenum, param: GLint }},

  texSubImage2D: { args: { target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, 
                           width: GLsizei, height: GLsizei, format: GLenum,
                           type: GLenum, pixels: ArrayBufferView }},
//  texSubImage2D: { args: { target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, 
//                           format: GLenum, type: GLenum, pixels: ImageData }},


  uniform1f: { args: { location: WebGLUniformLocation, x: GLfloat }},
  uniform1fv: { args: { location: WebGLUniformLocation, v: FloatArray }},
  uniform1i: { args: { location: WebGLUniformLocation, x: GLint }},
  uniform1iv: { args: { location: WebGLUniformLocation, v: Int32Array }},
  uniform2f: { args: { location: WebGLUniformLocation, x: GLfloat, y: GLfloat }},
  uniform2fv: { args: { location: WebGLUniformLocation, v: FloatArray }},
  uniform2i: { args: { location: WebGLUniformLocation, x: GLint, y: GLint }},
  uniform2iv: { args: { location: WebGLUniformLocation, v: Int32Array }},
  uniform3f: { args: { location: WebGLUniformLocation, x: GLfloat, y: GLfloat, z: GLfloat }},
  uniform3fv: { args: { location: WebGLUniformLocation, v: FloatArray }},
  uniform3i: { args: { location: WebGLUniformLocation, x: GLint, y: GLint, z: GLint }},
  uniform3iv: { args: { location: WebGLUniformLocation, x: Int32Array }},
  uniform4f: { args: { location: WebGLUniformLocation, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat }},
  uniform4fv: { args: { location: WebGLUniformLocation, v: FloatArray }},
  uniform4i: { args: { location: WebGLUniformLocation, x: GLint, y: GLint, z: GLint, w: GLint }},
  uniform4iv: { args: { location: WebGLUniformLocation, x: Int32Array }},
  
  uniformMatrix2fv: { args: { location: WebGLUniformLocation, transpose: GLboolean, value: FloatArray }},
  uniformMatrix3fv: { args: { location: WebGLUniformLocation, transpose: GLboolean, value: FloatArray }},
  uniformMatrix4fv: { args: { location: WebGLUniformLocation, transpose: GLboolean, value: FloatArray }},

  useProgram: { args: { program: WebGLProgram }},
  validateProgram: { args: { program: WebGLProgram }},

  vertexAttrib1f: { args: { indx: GLuint, x: GLfloat }},
  vertexAttrib1fv: { args: { indx: GLuint, values: FloatArray }},
  vertexAttrib2f: { args: { indx: GLuint, x: GLfloat, y: GLfloat }},
  vertexAttrib2fv: { args: { indx: GLuint, values: FloatArray }},
  vertexAttrib3f: { args: { indx: GLuint, x: GLfloat, y: GLfloat, z: GLfloat }},
  vertexAttrib3fv: { args: { indx: GLuint, values: FloatArray }},
  vertexAttrib4f: { args: { indx: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat }},
  vertexAttrib4fv: { args: { indx: GLuint, values: FloatArray }},
  vertexAttribPointer: { args: { indx: GLuint, size: GLint, type: GLenum, 
                         normalized: GLboolean, stride: GLsizei, offset: GLintptr }},
  
  viewport: { args: { x: GLint, y: GLint, width: GLsizei, height: GLsizei }},

}, function (api, name) {
  var sig = [];
  var args = [];
  var cargs = [];
  var fullArgs = [];
  var check = ["arguments.length === " + Object.keys(api.args).length];
  forEach(api.args, function (type, arg) {
    args.push(arg);
    if (typeof type === 'string') {
      sig.push(type);
      check.push('typeof ' + arg + ' === "' + type + '"');
      cargs.push(arg);
      fullArgs.push(type + " " + arg);
    } else {
      sig.push(type.name);
      fullArgs.push(type.name + " " + arg);
      if (type.name.substr(0, 5) === "WebGL") {
        cargs.push(arg + " ? " + arg + "._ : 0");
        check.push("(" + arg + " === null || " + arg + " instanceof " + type.name + ")");
      } else {
        cargs.push(arg);
        check.push("typeof " + arg + ' === "object"');
      }
      if (funcs.indexOf(type) < 0) { funcs.push(type); }
    }
  });
  args = args.join(", ");
  cargs = cargs.join(", ");
  fullArgs = fullArgs.join(", ");
  sig = sig.join(", ");
  check = check.join(" && ");
  if ((typeof api.result === 'function') && funcs.indexOf(api.result) < 0) { funcs.push(api.result); }

  process.stdout.write(
    "\nvar _" + name + " = gl." + name + ";\n" +
    "gl." + name + " = function " + name + "(" + args + ") {\n" +
    (check ? "  if (!(" + check + ")) {\n" +
    "    throw new TypeError('Expected " + name + "(" + fullArgs + ")');\n" +
    "  }\n" : "") +
    (typeof api.result === 'function' ? 
    "  return new " + api.result.name + "(_" + name + "(" + cargs + "));\n" :
    "  return _" + name + "(" + cargs + ");\n") +
    "}\n"
  );

});

process.stdout.write("\n////////////////////////////////////////////////////////////////////////////////\n\n");

funcs.forEach(function (func) {
  if (!func.length) return;
  console.log(func.toString());
});


////////////////////////////////////////////////////////////////////////////////

function forEach(object, callback, thisp) {
  var keys = Object.keys(object);
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    var value = object[key];
    if (arguments.length > 2) callback.call(thisp, value, key, keys);
    else callback(value, key, keys);
  }
}


